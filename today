持久化
日志
多线程
网络接口
缓存雪崩，击穿，穿透

数据类型：为了节约内存，应该定义一个结构体用来存储kv以及操作类型。该数据在内存中的引用位置有两种：缓存，memtable，需要用shared_ptr来智能维护

操纵器判断操作类型：{


    在缓存中的操作时间复杂度为o(1)，在memtable中为log(n)
    插入：{
        1.插入操作进日志
        2.为了保证数据一致性应该先从缓存内删除数据（缓存预留一个删除接口，能根据key值删除在内存中的kvnode引用，要注意判断空）此时在缓存中应该存在三种情况：{

            1.缓存中没有找到该kvnode的引用，此时证明数据改写失败，应该创建一个新的kvnode并插入memtable
            2.缓存中找到该kvnode的引用，但引用计数为1,证明该kvnode在内存只于缓存关联，该数据已经成功持久化，应该创建一个新的kvnode并插入memtable
            3.应该也插入kvnode,因为原kvnode可能在immemtable中，此时无法判断是否持久化
        }
        3.操纵器新建一个操作类型为插入的kvnode并插入到memtable中
        4.判断memtable的size大小,超过预定大小需要进行文件持久化，该过程由操纵器判断，超过size时交换判断上个memtable是否持久化完成，完成时进行新的持久化，开启一个新的线程用来持久化
    }

    查找：{
        1.从缓存内查找
        2.未找到从memtable中找
        3.从immemtable中查找
        4.从磁盘内查找
        5.找到{
            1.kvnode类型为数据，直接返回value的指针，把kvnode插入缓存
            2.kvnode类型为删除，返回nullptr,把删除操作node插入缓存
        }
        6.未找到把删除操作node插入缓存（解决缓存穿透，还差一个布隆过滤器在磁盘文件快速查找）
    }

    删除：{
        1.缓存中删除key
        2.在memtable中插入一个删除node
    }


}

缓存{
    根据操纵器要求，缓存要能够提供四个接口
    Insert(Key,Value) :查找时要判断kvnode引用计数，不存在或为1都要返回flase,为2时修改value返回true
    Insert(kvnode) ： 要能直接插入一个kvnode
    Remove(Key) ： 要能根据key删除对应的node ，可能不存在，此时直接返回即可
    Get(Key):根据key返回kvnode,不存在返回nullptr

    对于缓存的要求，要能缓存最近的热点数据并且能快速索引，要防止缓存污染，缓存雪崩，缓存击穿，缓存穿透，要保证缓存和数据库中的数据一致性

    要快速索引对应数据，选择哈希表，因为能快速索引，实现简单{
        缺点：哈希冲突
        解决：链式哈希
        缺点：查找速率可能退化
        解决：rehash 当负载因子超过预设值时增加哈希桶进行rehash
        缺点：rehash 时无法操作缓存
        解决：渐进式rehash
    }

    防止缓存污染：使用LRU缓存机制

    缓存雪崩，击穿？

    缓存穿透：如果查找结果为空时也向缓存中插入删除类型节点，引入布隆过滤器快速查找

}

memtable{ //建立理由为减少IO操作，批量写
    根据操纵器要求，memtable要能提供两个接口
    Insert(kvnode)： 要能直接插入一个kvnode
    Get(Key):根据key返回kvnode,不存在返回nullptr

    当size超过预设值时需要进行持久化{
        防止阻塞进程，无法写入memtable,在table内定义两个memtable,当size超过预设值时交换。
        一个用来持久化，一个用来写入读取
    }
}

sstable 持久化{
    考虑数据在文件中的存储形式。--- 是否需要压缩  前缀压缩
    要能快速判断文件内有没有该key --- 布隆过滤器
    要能快速定位文件内的key --- 二分查找
}

4.20
今天考虑完成文件内二分查找